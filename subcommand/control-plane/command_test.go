package controlplane

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/hashicorp/go-hclog"
	"github.com/hashicorp/go-uuid"

	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/hashicorp/consul-ecs/awsutil"
	"github.com/hashicorp/consul-ecs/config"
	"github.com/hashicorp/consul-ecs/testutil"
	"github.com/hashicorp/consul/api"
	"github.com/mitchellh/cli"
	"github.com/stretchr/testify/require"
)

// testCACertPem is the contents of the CA cert file, as generated by `consul tls ca create`.
// This must be valid format, but tests otherwise don't care about the contents of the cert.
const testCACertPem = `-----BEGIN CERTIFICATE-----
MIIC7zCCApSgAwIBAgIRAIwPbv+5UWX9Y8BGn0b0fCYwCgYIKoZIzj0EAwIwgbkx
CzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEWMBQGA1UEBxMNU2FuIEZyYW5jaXNj
bzEaMBgGA1UECRMRMTAxIFNlY29uZCBTdHJlZXQxDjAMBgNVBBETBTk0MTA1MRcw
FQYDVQQKEw5IYXNoaUNvcnAgSW5jLjFAMD4GA1UEAxM3Q29uc3VsIEFnZW50IENB
IDE4NjE3MjA1NTE4ODM1NzIxODg4MzY4MDEzMjI1MDY0MTY2MDk2NjAeFw0yMjA3
MTgyMDE5MTBaFw0yNzA3MTcyMDE5MTBaMIG5MQswCQYDVQQGEwJVUzELMAkGA1UE
CBMCQ0ExFjAUBgNVBAcTDVNhbiBGcmFuY2lzY28xGjAYBgNVBAkTETEwMSBTZWNv
bmQgU3RyZWV0MQ4wDAYDVQQREwU5NDEwNTEXMBUGA1UEChMOSGFzaGlDb3JwIElu
Yy4xQDA+BgNVBAMTN0NvbnN1bCBBZ2VudCBDQSAxODYxNzIwNTUxODgzNTcyMTg4
ODM2ODAxMzIyNTA2NDE2NjA5NjYwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARD
RBQDHmseBTU6+QRr+3tO7rgqlMqFRtjLUf0PSU4Pq8O+NlMiWPmg8qO423n9Fuln
P9aCzMMQ3Yox8jiRT/nyo3sweTAOBgNVHQ8BAf8EBAMCAYYwDwYDVR0TAQH/BAUw
AwEB/zApBgNVHQ4EIgQgYOJpfrlzkN/VEUmHUEjpVNLTipbfl6uHjYavhG0X0kEw
KwYDVR0jBCQwIoAgYOJpfrlzkN/VEUmHUEjpVNLTipbfl6uHjYavhG0X0kEwCgYI
KoZIzj0EAwIDSQAwRgIhAM53NrwKLUAc3LrdqvANGSd+U0IAMAx/ITKlC3X9nVKt
AiEA5IMIHJsYyyNDd+lb9qODQjbs5TA71uo3RhILp0hZjKk=
-----END CERTIFICATE-----`

func TestNoCLIFlagsSupported(t *testing.T) {
	ui := cli.NewMockUi()
	cmd := Command{UI: ui}
	code := cmd.Run([]string{"some-arg"})
	require.Equal(t, 1, code)
	require.Equal(t, "unexpected argument: some-arg\n", ui.ErrorWriter.String())
}

func TestConfigValidation(t *testing.T) {
	t.Run("CONSUL_ECS_CONFIG_JSON unset", func(t *testing.T) {
		ui := cli.NewMockUi()
		cmd := Command{UI: ui}
		code := cmd.Run(nil)
		require.Equal(t, code, 1)
		require.Contains(t, ui.ErrorWriter.String(),
			fmt.Sprintf(`invalid config: "%s" isn't populated`, config.ConfigEnvironmentVariable))

	})
	t.Run("CONSUL_ECS_CONFIG_JSON is empty json", func(t *testing.T) {
		testutil.SetECSConfigEnvVar(t, map[string]interface{}{})
		ui := cli.NewMockUi()
		cmd := Command{UI: ui}
		code := cmd.Run(nil)
		require.Equal(t, code, 1)
		require.Contains(t, ui.ErrorWriter.String(), "invalid config: 1 error occurred:")
	})
}

// Note: this test cannot currently run in parallel with other tests
// because it sets environment variables (e.g. ECS metadata URI and Consul's HTTP addr)
// that could not be shared if another test were to run in parallel.
func TestMeshInit(t *testing.T) {
	var (
		family      = "family-SERVICE-name"
		serviceName = "service-name"

		// Note: TaggedAddressees may be set, but it seems like a race.
		// We don't support tproxy in ECS, so I don't think we care about this?
		agentServiceIgnoreFields = cmpopts.IgnoreFields(api.AgentService{},
			"ContentHash", "ModifyIndex", "CreateIndex", "TaggedAddresses")
		checkIgnoreFields = cmpopts.IgnoreFields(api.HealthCheck{}, "CreateIndex", "ModifyIndex")
	)

	cases := map[string]struct {
		servicePort       int
		upstreams         []config.Upstream
		expUpstreams      []api.Upstream
		tags              []string
		expTags           []string
		additionalMeta    map[string]string
		expAdditionalMeta map[string]string
		serviceName       string
		expServiceName    string

		consulLogin config.ConsulLogin
	}{
		"basic service": {},
		"service with port": {
			servicePort: 8080,
		},
		"service with upstreams": {
			upstreams: []config.Upstream{
				{
					DestinationName: "upstream1",
					LocalBindPort:   1234,
				},
				{
					DestinationName: "upstream2",
					LocalBindPort:   1235,
				},
			},
			expUpstreams: []api.Upstream{
				{
					DestinationName: "upstream1",
					LocalBindPort:   1234,
				},
				{
					DestinationName: "upstream2",
					LocalBindPort:   1235,
				},
			},
		},
		// TODO:
		//"with healthsync": {
		//	healthSyncContainers: []string{"my-container"},
		//},
		"service with tags": {
			tags:    []string{"tag1", "tag2"},
			expTags: []string{"tag1", "tag2"},
		},
		"service with additional metadata": {
			additionalMeta:    map[string]string{"a": "1", "b": "2"},
			expAdditionalMeta: map[string]string{"a": "1", "b": "2"},
		},
		"service with service name": {
			serviceName:    serviceName,
			expServiceName: serviceName,
		},
	}

	for name, c := range cases {
		t.Run(name, func(t *testing.T) {
			var (
				clusterARN       = "arn:aws:ecs:us-east-1:123456789:cluster/test"
				taskARN          = "arn:aws:ecs:us-east-1:123456789:task/test/abcdef"
				expectedTaskMeta = map[string]string{
					"task-id":  "abcdef",
					"task-arn": taskARN,
					"source":   "consul-ecs",
				}
				expectedServiceName = strings.ToLower(family)
				expectedPartition   = ""
				expectedNamespace   = ""
			)

			if testutil.EnterpriseFlag() {
				expectedPartition = "default"
				expectedNamespace = "default"
			}

			for k, v := range c.expAdditionalMeta {
				expectedTaskMeta[k] = v
			}

			expectedTags := c.expTags
			if expectedTags == nil {
				expectedTags = []string{}
			}

			if c.expServiceName != "" {
				expectedServiceName = c.expServiceName
			}

			for i := range c.upstreams {
				c.upstreams[i].DestinationPartition = expectedPartition
				c.upstreams[i].DestinationNamespace = expectedNamespace
			}
			for i := range c.expUpstreams {
				c.expUpstreams[i].DestinationPartition = expectedPartition
				c.expUpstreams[i].DestinationNamespace = expectedNamespace
			}

			var srvConfig testutil.ServerConfigCallback
			if c.consulLogin.Enabled {
				// Enable ACLs to test with the auth method
				srvConfig = testutil.ConsulACLConfigFn
			}

			// Start a Consul server. This sets the CONSUL_HTTP_ADDR for `consul connect envoy -bootstrap`.
			cfg, consulServers := testutil.ConsulServer(t, srvConfig)
			consulClient, err := api.NewClient(cfg)
			require.NoError(t, err)

			expNode := clusterARN
			expSvcAddr := "10.1.2.3"

			taskMeta := awsutil.ECSTaskMeta{
				Cluster: clusterARN,
				TaskARN: taskARN,
				Family:  family,
				Containers: []awsutil.ECSTaskMetaContainer{
					{
						Networks: []awsutil.ECSTaskMetaNetwork{
							{
								IPv4Addresses:  []string{expSvcAddr},
								PrivateDNSName: expNode,
							},
						},
					},
				},
			}

			// NOTE: Normally, the consulClient in meshInit doesn't have node:write permissions
			// so the catalog registration would fail if the node is not created first (i.e. by the
			// controller). In this test case, we're passing in a privileged client since we care
			// while TestRun will validate the full sequence.

			ui := cli.NewMockUi()

			envoyBootstrapDir := testutil.TempDir(t)
			envoyBootstrapFile := filepath.Join(envoyBootstrapDir, envoyBoostrapConfigFilename)
			copyConsulECSBinary := filepath.Join(envoyBootstrapDir, "consul-ecs")

			consulEcsConfig := config.Config{
				ConsulServers:        consulServers,
				BootstrapDir:         envoyBootstrapDir,
				HealthSyncContainers: nil,
				ConsulLogin:          c.consulLogin,
				Proxy: &config.AgentServiceConnectProxyConfig{
					Upstreams: c.upstreams,
				},
				Service: config.ServiceRegistration{
					Name: c.serviceName,
					Port: c.servicePort,
					Tags: c.tags,
					Meta: c.additionalMeta,
				},
			}

			cmd := Command{UI: ui, config: &consulEcsConfig, log: hclog.New(&hclog.LoggerOptions{
				Name:  "mesh-init",
				Level: hclog.Debug,
			})}
			err = cmd.meshInit(consulClient, taskMeta)
			require.NoError(t, err, ui.ErrorWriter.String())

			expServiceID := fmt.Sprintf("%s-abcdef", expectedServiceName)
			expSidecarServiceID := fmt.Sprintf("%s-abcdef-sidecar-proxy", expectedServiceName)

			expectedServiceRegistration := &api.AgentService{
				ID:      expServiceID,
				Address: expSvcAddr,
				Service: expectedServiceName,
				Port:    c.servicePort,
				Meta:    expectedTaskMeta,
				Tags:    expectedTags,
				// Datacenter: "dc1",
				Weights: api.AgentWeights{
					Passing: 1,
					Warning: 1,
				},
				Partition: expectedPartition,
				Namespace: expectedNamespace,
				Proxy:     &api.AgentServiceConnectProxyConfig{},
				Connect:   &api.AgentServiceConnect{},
			}

			expSidecarSvcName := fmt.Sprintf("%s-sidecar-proxy", expectedServiceName)
			expectedProxyServiceRegistration := &api.AgentService{
				ID:      expSidecarServiceID,
				Address: expSvcAddr,
				Service: expSidecarSvcName,
				Port:    20000,
				Kind:    api.ServiceKindConnectProxy,
				Proxy: &api.AgentServiceConnectProxyConfig{
					DestinationServiceName: expectedServiceName,
					DestinationServiceID:   expServiceID,
					LocalServicePort:       c.servicePort,
					Upstreams:              c.expUpstreams,
				},
				Meta: expectedTaskMeta,
				Tags: expectedTags,
				// Datacenter: "dc1",
				Weights: api.AgentWeights{
					Passing: 1,
					Warning: 1,
				},
				Partition: expectedPartition,
				Namespace: expectedNamespace,
				Connect:   &api.AgentServiceConnect{},
			}

			service, _, err := consulClient.Catalog().NodeServiceList(expNode, nil)
			require.NoError(t, err)

			t.Logf("node: %#v", service.Node)
			for _, svc := range service.Services {
				t.Logf("service: %#v", svc)
				t.Logf("service.Proxy: %#v", svc.Proxy)
			}
			require.Empty(t, cmp.Diff(expectedServiceRegistration, service.Services[0], agentServiceIgnoreFields))
			require.Empty(t, cmp.Diff(expectedProxyServiceRegistration, service.Services[1], agentServiceIgnoreFields))

			checks, _, err := consulClient.Health().Checks(expectedServiceName, &api.QueryOptions{
				Filter: fmt.Sprintf(`ServiceID == "%s"`, expServiceID),
			})
			require.NoError(t, err)

			// TODO: Different if healthSyncContainers is provided.
			expTags := []string{}
			if len(c.expTags) > 0 {
				expTags = c.expTags
			}
			require.Empty(t, cmp.Diff(checks, api.HealthChecks{
				{
					Node:        expNode,
					CheckID:     expServiceID + "-check",
					Name:        expectedServiceName,
					Status:      api.HealthPassing,
					Output:      "Task started.",
					ServiceID:   expServiceID,
					ServiceName: expectedServiceName,
					Type:        ConsulECSCheckType,
					ServiceTags: expTags,
				},
			}, checkIgnoreFields))

			// PROXY CHECKS
			checks, _, err = consulClient.Health().Checks(expSidecarSvcName, &api.QueryOptions{
				Filter: fmt.Sprintf(`ServiceID == "%s"`, expSidecarServiceID),
			})
			require.NoError(t, err)

			require.Empty(t, cmp.Diff(checks, api.HealthChecks{
				{
					Node:        expNode,
					CheckID:     expSidecarServiceID + "-check",
					Name:        expSidecarSvcName,
					Status:      api.HealthCritical,
					Output:      "Task is starting. Container sidecar-proxy not yet healthy.",
					ServiceID:   expSidecarServiceID,
					ServiceName: expSidecarSvcName,
					Type:        ConsulECSCheckType,
					ServiceTags: expTags,
				},
			}, checkIgnoreFields))

			envoyBootstrapContents, err := os.ReadFile(envoyBootstrapFile)
			require.NoError(t, err)
			require.NotEmpty(t, envoyBootstrapContents)

			copyConsulEcsStat, err := os.Stat(copyConsulECSBinary)
			require.NoError(t, err)
			require.Equal(t, "consul-ecs", copyConsulEcsStat.Name())
			require.Equal(t, os.FileMode(0755), copyConsulEcsStat.Mode())

		})
	}
}

func TestGateway(t *testing.T) {
	t.Skip("gateway test skipped for agentless hack")
	var (
		family               = "family-name-mesh-gateway"
		serviceName          = "service-name-mesh-gateway"
		taskARN              = "arn:aws:ecs:us-east-1:123456789:task/test/abcdef"
		taskIP               = "10.1.2.3"
		publicIP             = "255.1.2.3"
		taskDNSName          = "test-dns-name"
		taskMetadataResponse = fmt.Sprintf(`{"Cluster": "test","TaskARN": "%s","Family": "%s","Containers":[{"Networks":[{"IPv4Addresses":["%s"],"PrivateDNSName":"%s"}]}]}`, taskARN, family, taskIP, taskDNSName)
		expectedTaskMeta     = map[string]string{
			"task-id":  "abcdef",
			"task-arn": taskARN,
			"source":   "consul-ecs",
		}
	)

	// Simulate mesh gateway registration:
	// Specify "gateway" and "service" configuration, and verify the details of the registered service.
	cases := map[string]struct {
		config *config.Config

		expServiceID       string
		expServiceName     string
		expLanAddress      string
		expWanAddress      string
		expTaggedAddresses map[string]api.ServiceAddress
		expLanPort         int
	}{
		"mesh gateway default port": {
			config: &config.Config{
				Gateway: &config.GatewayRegistration{
					Kind: api.ServiceKindMeshGateway,
				},
			},
			expServiceID:   family + "-abcdef",
			expServiceName: family,
			expLanPort:     8443, // default gateway port if unspecified
		},
		"mesh gateway with port": {
			config: &config.Config{
				Gateway: &config.GatewayRegistration{
					Kind: api.ServiceKindMeshGateway,
					LanAddress: &config.GatewayAddress{
						Port: 12345,
					},
				},
			},
			expServiceID:   family + "-abcdef",
			expServiceName: family,
			expLanPort:     12345,
		},
		"mesh gateway with service name": {
			config: &config.Config{
				Gateway: &config.GatewayRegistration{
					Kind: api.ServiceKindMeshGateway,
					LanAddress: &config.GatewayAddress{
						Port: 12345,
					},
					Name: serviceName,
				},
			},
			expServiceID:   serviceName + "-abcdef",
			expServiceName: serviceName,
			expLanPort:     12345,
		},
		"mesh gateway with lan address": {
			config: &config.Config{
				Gateway: &config.GatewayRegistration{
					Kind: api.ServiceKindMeshGateway,
					LanAddress: &config.GatewayAddress{
						Address: taskIP,
						Port:    12345,
					},
					Name: serviceName,
				},
			},
			expServiceID:   serviceName + "-abcdef",
			expServiceName: serviceName,
			expLanAddress:  taskIP,
			expLanPort:     12345,
			expTaggedAddresses: map[string]api.ServiceAddress{
				"lan": {
					Address: taskIP,
					Port:    12345,
				},
				"lan_ipv4": {
					Address: taskIP,
					Port:    12345,
				},
				"wan_ipv4": {
					Address: taskIP,
					Port:    12345,
				},
			},
		},
		"mesh gateway with wan address": {
			config: &config.Config{
				Gateway: &config.GatewayRegistration{
					Kind: api.ServiceKindMeshGateway,
					WanAddress: &config.GatewayAddress{
						Address: publicIP,
						Port:    12345,
					},
				},
				Service: config.ServiceRegistration{},
			},
			expServiceID:   family + "-abcdef",
			expServiceName: family,
			expLanPort:     8443, // default gateway port
			expLanAddress:  "",
			expTaggedAddresses: map[string]api.ServiceAddress{
				"wan": {
					Address: publicIP,
					Port:    12345,
				},
			},
		},
	}
	for name, c := range cases {
		t.Run(name, func(t *testing.T) {
			apiCfg, consulServers := testutil.ConsulServer(t, nil)
			testutil.TaskMetaServer(t, testutil.TaskMetaHandler(t, taskMetadataResponse))

			c.config.ConsulServers = consulServers

			c.config.BootstrapDir = testutil.TempDir(t)
			testutil.SetECSConfigEnvVar(t, c.config)

			consulClient, err := api.NewClient(apiCfg)
			require.NoError(t, err)

			ui := cli.NewMockUi()
			cmd := Command{UI: ui}

			code := cmd.Run(nil)
			require.Equal(t, code, 0, ui.ErrorWriter.String())

			var partition, namespace string
			if testutil.EnterpriseFlag() {
				// TODO add enterprise tests
				partition = "default"
				namespace = "default"
			}

			expectedServiceRegistration := &api.AgentService{
				Kind:            c.config.Gateway.Kind,
				ID:              c.expServiceID,
				Service:         c.expServiceName,
				Proxy:           &api.AgentServiceConnectProxyConfig{},
				Address:         c.expLanAddress,
				Port:            c.expLanPort,
				Meta:            expectedTaskMeta,
				Tags:            []string{},
				Datacenter:      "dc1",
				TaggedAddresses: c.expTaggedAddresses,
				Partition:       partition,
				Namespace:       namespace,
				Weights: api.AgentWeights{
					Passing: 1,
					Warning: 1,
				},
			}

			agentServiceIgnoreFields := cmpopts.IgnoreFields(api.AgentService{},
				"ContentHash", "ModifyIndex", "CreateIndex")

			service, _, err := consulClient.Agent().Service(expectedServiceRegistration.ID, nil)
			require.NoError(t, err)
			require.Empty(t, cmp.Diff(expectedServiceRegistration, service, agentServiceIgnoreFields))

		})
	}
}

func TestClientInit(t *testing.T) {
	var (
		taskMeta = awsutil.ECSTaskMeta{
			Cluster: "arn:aws:ecs:us-east-1:123456789:cluster/my-cluster",
			TaskARN: "arn:aws:ecs:us-east-1:123456789:task/my-cluster/abcdef",
			Family:  "test-service",
		}
		cfgIgnoreFields = cmpopts.IgnoreFields(api.Config{}, "Transport", "HttpClient", "Token")
	)

	cases := map[string]struct {
		caCertEnvVar bool
		conf         config.Config

		expCfg *api.Config
		expErr string
	}{
		"http addr": {
			conf: config.Config{
				ConsulServers: config.ConsulServers{
					Hosts: "127.1.2.3",
					HTTPS: false,
				},
			},
			expCfg: &api.Config{
				Address: "127.1.2.3:8501",
				Scheme:  "http",
			},
		},
		"https addr": {
			conf: config.Config{
				ConsulServers: config.ConsulServers{
					Hosts: "127.1.2.3",
					HTTPS: true,
				},
			},
			expCfg: &api.Config{
				Address: "127.1.2.3:8501",
				Scheme:  "https",
			},
		},
		"ca cert": {
			caCertEnvVar: true,
			conf: config.Config{
				ConsulServers: config.ConsulServers{
					Hosts: "127.1.2.3",
					HTTPS: true,
				},
			},
			expCfg: &api.Config{
				Address: "127.1.2.3:8501",
				Scheme:  "https",
			},
		},
	}
	for name, c := range cases {
		c := c
		t.Run(name, func(t *testing.T) {
			c.conf.BootstrapDir = testutil.TempDir(t)

			if c.caCertEnvVar {
				t.Cleanup(func() { _ = os.Unsetenv(config.ConsulCACertEnvVar) })
				err := os.Setenv(config.ConsulCACertEnvVar, testCACertPem)
				require.NoError(t, err)

				caFile := filepath.Join(c.conf.BootstrapDir, "test-ca-cert.pem")
				c.conf.ConsulServers.CACertFile = caFile
				c.expCfg.TLSConfig.CAFile = caFile
			}

			cmd := &Command{
				config: &c.conf,
				log: hclog.New(&hclog.LoggerOptions{
					Name:  "client-init",
					Level: hclog.Debug,
				}),
			}
			client, cfg, err := cmd.clientInit(taskMeta)

			if c.expErr != "" {
				require.Error(t, err)
				require.Contains(t, err.Error(), c.expErr)
				require.Nil(t, client)
				require.Nil(t, cfg)
			} else {
				require.NoError(t, err)
				require.Empty(t, cmp.Diff(c.expCfg, cfg, cfgIgnoreFields))
				require.NotNil(t, client)
			}

		})
	}

	// Test with login enabled. I guess I can remove this, since we hit this in the TestRun.
	t.Run("login enabled", func(t *testing.T) {
		cfg, consulServers := testutil.ConsulServer(t, testutil.ConsulACLConfigFn)
		client, err := api.NewClient(cfg)
		require.NoError(t, err)

		fakeAws := testutil.AuthMethodInit(t, client, "test-service")

		conf := config.Config{
			BootstrapDir:  testutil.TempDir(t),
			ConsulServers: consulServers,
			ConsulLogin: config.ConsulLogin{
				Enabled:       true,
				IncludeEntity: true,
				// Point `consul login` at the local fake AWS server.
				ExtraLoginFlags: []string{
					"-aws-sts-endpoint", fakeAws.URL + "/sts",
					"-aws-region", "fake-region",
					"-aws-access-key-id", "fake-key-id",
					"-aws-secret-access-key", "fake-secret-key",
				},
			},
		}
		// Expect the TokenFile to be configured for login.
		expCfg := &api.Config{
			TokenFile: filepath.Join(conf.BootstrapDir, config.ServiceTokenFilename),
			Address:   cfg.Address,
			Scheme:    cfg.Scheme,
		}

		{
			cmd := &Command{
				config: &conf,
				log: hclog.New(&hclog.LoggerOptions{
					Name:  "client-init",
					Level: hclog.Debug,
				}),
			}

			client, cfg, err := cmd.clientInit(taskMeta)
			require.NotNil(t, client)
			require.NotNil(t, cfg)
			require.Empty(t, cmp.Diff(expCfg, cfg, cfgIgnoreFields))
			require.NoError(t, err)
		}

	})

}

func TestConstructServiceRegistration(t *testing.T) {
	var (
		clusterArn = "arn:aws:ecs:us-east-1:123456789:cluster/my-cluster"
		taskID     = "abcdef"
		taskARN    = "arn:aws:ecs:us-east-1:123456789:task/my-cluster/" + taskID
		taskIP     = "127.1.2.3"

		taskMeta = awsutil.ECSTaskMeta{
			Cluster: clusterArn,
			TaskARN: taskARN,
			Family:  "test-SERVICE",
			Containers: []awsutil.ECSTaskMetaContainer{
				{
					Networks: []awsutil.ECSTaskMetaNetwork{
						{
							IPv4Addresses: []string{taskIP},
						},
					},
				},
			},
		}

		expServiceName = strings.ToLower(taskMeta.Family)
		expServiceId   = expServiceName + "-" + taskID
		expTaskMeta    = map[string]string{
			"task-id":  taskID,
			"task-arn": taskARN,
			"source":   "consul-ecs",
		}
	)

	cases := map[string]struct {
		conf *config.Config

		exp *api.CatalogRegistration
	}{
		"no health sync": {
			conf: &config.Config{},
			exp: &api.CatalogRegistration{
				Node: clusterArn,
				Service: &api.AgentService{
					Kind:      "",
					ID:        expServiceId,
					Service:   expServiceName,
					Meta:      expTaskMeta,
					Address:   taskIP,
					Namespace: "",
					Partition: "",
				},
				Checks: []*api.HealthCheck{
					{
						CheckID:     expServiceId + "-check",
						Name:        expServiceName,
						Status:      api.HealthPassing,
						Output:      "Task started.",
						ServiceID:   expServiceId,
						ServiceName: expServiceName,
						Type:        ConsulECSCheckType,
					},
				},
				SkipNodeUpdate: true,
			},
		},
		"one health sync": {
			conf: &config.Config{
				HealthSyncContainers: []string{"my-container"},
			},
			exp: &api.CatalogRegistration{
				Node: clusterArn,
				Service: &api.AgentService{
					ID:      expServiceId,
					Service: expServiceName,
					Meta:    expTaskMeta,
					Address: taskIP,
				},
				Checks: []*api.HealthCheck{
					{
						// check id includes the container name
						CheckID:     expServiceId + "-my-container-check",
						Name:        expServiceName,
						Status:      api.HealthCritical,
						Output:      "Task is starting. Container my-container not yet healthy.",
						ServiceID:   expServiceId,
						ServiceName: expServiceName,
						Type:        ConsulECSCheckType,
					},
				},
				SkipNodeUpdate: true,
			},
		},
	}
	for name, c := range cases {
		t.Run(name, func(t *testing.T) {
			cmd := Command{config: c.conf}

			reg, err := cmd.constructServiceRegistration(taskMeta)
			require.NoError(t, err)
			require.Equal(t, c.exp, reg)
		})
	}
}

func TestConstructServiceName(t *testing.T) {
	cmd := Command{config: &config.Config{}}
	family := "family"

	serviceName := cmd.constructServiceName(family)
	require.Equal(t, family, serviceName)

	serviceName = cmd.constructServiceName("FAMILY")
	require.Equal(t, family, serviceName)

	expectedServiceName := "service-name"

	cmd.config.Service.Name = expectedServiceName
	serviceName = cmd.constructServiceName(family)
	require.Equal(t, expectedServiceName, serviceName)
}

func TestConstructLoginCmd(t *testing.T) {
	var (
		taskARN = "arn:aws:ecs:bogus-east-1:123456789:task/test/abcdef"
		meta    = awsutil.ECSTaskMeta{
			Cluster: "my-cluster",
			TaskARN: taskARN,
			Family:  "my-service",
		}
		method     = "test-method"
		tokenFile  = "test-file"
		httpAddr   = "consul.example.com"
		caCertFile = "my-ca-cert.pem"
	)

	cases := map[string]struct {
		config *config.Config
		expCmd []string
	}{
		"defaults": {
			config: &config.Config{
				ConsulServers: config.ConsulServers{
					Hosts:      httpAddr,
					CACertFile: caCertFile,
				},
				ConsulLogin: config.ConsulLogin{
					Method:        method,
					IncludeEntity: true, // defaults to true, when parsed from JSON
				},
			},
			expCmd: []string{
				"login", "-type", "aws", "-method", method,
				"-http-addr", httpAddr,
				"-ca-file", caCertFile,
				"-token-sink-file", tokenFile,
				"-meta", "consul.hashicorp.com/task-id=abcdef",
				"-meta", "consul.hashicorp.com/cluster=my-cluster",
				"-aws-region", "bogus-east-1",
				"-aws-auto-bearer-token", "-aws-include-entity",
			},
		},
		"fewest fields": {
			config: &config.Config{
				ConsulLogin: config.ConsulLogin{
					Method:        method,
					IncludeEntity: false,
				},
			},
			expCmd: []string{
				"login", "-type", "aws", "-method", method,
				"-http-addr", "", // unset
				"-ca-file", "",
				"-token-sink-file", tokenFile,
				"-meta", "consul.hashicorp.com/task-id=abcdef",
				"-meta", "consul.hashicorp.com/cluster=my-cluster",
				"-aws-region", "bogus-east-1",
				"-aws-auto-bearer-token",
				// no -aws-include-entity
			},
		},
		"all fields": {
			config: &config.Config{
				ConsulServers: config.ConsulServers{
					Hosts:      httpAddr,
					CACertFile: caCertFile,
				},
				ConsulLogin: config.ConsulLogin{
					Method:          method,
					IncludeEntity:   true,
					ExtraLoginFlags: []string{"-aws-server-id-header-value", "abcd"},
				},
			},
			expCmd: []string{
				"login", "-type", "aws", "-method", method,
				"-http-addr", httpAddr,
				"-ca-file", caCertFile,
				"-token-sink-file", tokenFile,
				"-meta", "consul.hashicorp.com/task-id=abcdef",
				"-meta", "consul.hashicorp.com/cluster=my-cluster",
				"-aws-region", "bogus-east-1",
				"-aws-auto-bearer-token", "-aws-include-entity",
				"-aws-server-id-header-value", "abcd",
			},
		},
	}
	for name, c := range cases {
		t.Run(name, func(t *testing.T) {
			cmd := &Command{config: c.config}
			loginOpts, err := cmd.constructLoginCmd(tokenFile, meta)
			require.NoError(t, err)
			require.Equal(t, c.expCmd, loginOpts)
		})
	}
}

func TestWaitForTokenReplication(t *testing.T) {
	cfg, consulServers := testutil.ConsulServer(t, testutil.ConsulACLConfigFn)
	client, err := api.NewClient(cfg)
	require.NoError(t, err)

	cases := []struct {
		lagTime  time.Duration
		expError bool
	}{
		{lagTime: 50 * time.Millisecond},
		{lagTime: 100 * time.Millisecond},
		{lagTime: 500 * time.Millisecond},
		// 2s is as long as we wait.
		{lagTime: 2500 * time.Millisecond, expError: true},
	}
	for _, c := range cases {
		name := c.lagTime.String()
		t.Run(name, func(t *testing.T) {
			accessorID, err := uuid.GenerateUUID()
			require.NoError(t, err)
			secretID, err := uuid.GenerateUUID()
			require.NoError(t, err)

			tokenCfg := api.DefaultConfig()
			tokenCfg.Token = secretID

			tokenClient, err := api.NewClient(tokenCfg)
			require.NoError(t, err)

			// After c.lagTime, create the token.
			//
			// This simulates the token not existing for a short period of time
			// on the Consul server. This is not the exact replication lag
			// between two Consul servers, but close enough to exercise the code.
			timer := time.AfterFunc(
				c.lagTime,
				func() {
					token, _, err := client.ACL().TokenCreate(&api.ACLToken{
						AccessorID: accessorID,
						SecretID:   secretID,
					}, nil)
					require.NoError(t, err)
					// Sanity check
					require.Equal(t, accessorID, token.AccessorID)
					require.Equal(t, secretID, token.SecretID)
				},
			)
			t.Cleanup(func() { timer.Stop() })

			// Wait for the token to "replicate".
			cmd := &Command{
				log: hclog.NewNullLogger(),
				config: &config.Config{
					ConsulServers: consulServers,
				},
			}
			err = cmd.waitForTokenReplication(tokenClient)
			if c.expError {
				require.Error(t, err)
			} else {
				require.NoError(t, err)

				// Token should exist.
				token, _, err := tokenClient.ACL().TokenReadSelf(nil)
				require.NoError(t, err)
				require.Equal(t, accessorID, token.AccessorID)
				require.Equal(t, secretID, token.SecretID)
			}

		})
	}
}

// toAgentCheck translates the request type (AgentServiceCheck) into an "expected"
// response type (AgentCheck) which we can use in assertions.
func toAgentCheck(check config.AgentServiceCheck) *api.AgentCheck {
	expInterval, _ := time.ParseDuration(check.Interval)
	expTimeout, _ := time.ParseDuration(check.Timeout)
	expPartition := ""
	expNamespace := ""
	if testutil.EnterpriseFlag() {
		expPartition = "default"
		expNamespace = "default"
	}
	return &api.AgentCheck{
		CheckID:   check.CheckID,
		Name:      check.Name,
		Notes:     check.Notes,
		Partition: expPartition,
		Namespace: expNamespace,
		Definition: api.HealthCheckDefinition{
			// HealthCheckDefinition does not have GRPC or TTL fields.
			HTTP:             check.HTTP,
			Header:           check.Header,
			Method:           check.HTTP,
			Body:             check.Body,
			TLSServerName:    check.TLSServerName,
			TLSSkipVerify:    check.TLSSkipVerify,
			TCP:              check.TCP,
			IntervalDuration: expInterval,
			TimeoutDuration:  expTimeout,
			Interval:         api.ReadableDuration(expInterval),
			Timeout:          api.ReadableDuration(expTimeout),
		},
	}
}
